Solution of Prime Calculation Task
===================================

Von der Idee her hätt ich überlegt, einen Iterator i von p-1 bis 2 laufen zu lassen und für jedes i zu überprüfen ob p%i==0 gilt. Wenn ja, dann ist es keine Primzahl und der Algorithmus bricht ab. Wenn nein, dann wird i dekrementert und weiter überprüft. Ist einmal i<2, dann gab es keinen Fall von p%i==0 und somit ist die gegebene Zahl eine Primzahl.
Ich hätte vorgeschlagen dass wir den Stack in der Größenordnung O(1) halten, somit keine "echte" Rekursion, sondern i schon in-place dekrementieren. Das würde für große p Speicher sparen und beim Auflösen der "Rekursion" schneller gehen.
Außerdem müssen p und B dann nicht immer mitgeschleppt werden sondern können immer von der Originalposition eingelesen/kopiert werden.

Code *untested*:

p ... gegebene Primzahl
C ... if-then-else aus der Angabe
B ... rekursiver Aufruf, der i dekrementiert, und die Auswertung /
einen weiteren rekursiven Aufruf zurückgibt

Programm: p B 3c 3c a 3d 3d 3d

B: [1- 2c 2< [0] [4c 3c % 0= [[1]] [3c] Ca a] Ca]

C: [4c 5d 2+ d a]

/Code

Anmerkungen:
(Jetzt wär es nett wenn ich direkt zu den Ausdrücken was dazuschreiben könnte)

(Programm)
p B ... Primzahl und rekursives Programm welches bis zum Schluss am Stack bleiben
3c 3c ... Kopien von p und B mit welchen gearbeitet wird
a ... erster Aufruf von B
3d 3d 3d ... nachdem B terminiert ist und entweder 0 oder 1 zurückgegeben hat, werden das ursprüngliche p B und der aktuelle Iterator i gelöscht und es bleibt nur das Ergebnis übrig

(B)
1- ... den Iterator (steht am Stack immer nach p und B) in-place dekrementieren - wird auch vor dem ersten Vergleich benötigt, da p%p natürlich 0 ergibt...
2c ... i kopieren damit darauf gearbeitet werden kann
2< ... überprüfen, ob i<2 ist, denn dann soll abgebrochen werden
[0] ... True-Zweig von (i<2), B terminiert damit und gibt True zurück, da kein Fall aufgetreten ist, in dem p%i==0 war
[4c 3c % 0= [[1]] [3c] Ca a] .. False-Zweig von (i<2), überprüft auf
p%i==0 und je nach Ergebnis wird False zurückgegeben, oder ein weiterer rekursiver Aufruf getätigt
Ca ... führt entweder den True- oder den False-Zweig von (i<2) aus

([4c 3c % 0= [[1]] [3c] Ca a])
4c 3c ... hole Kopien von p und i um damit arbeiten zu können - Vorsicht, Denkfalle: der Platz am Stack vom True- oder False-Wert des (i<2)-Vergleichs ist an dieser Stelle schon freigegeben!
% ... Modulo-Operation p%i
0= ... Vergleich, ob die Modulo-Operation 0 geliefert hat (keine Primzahl => linker Zweig), oder nicht (weiter rekursieren => rechter Zweig)
[[1]] ... keine Primzahl, 1 wird zurückgegeben
[3c] ... B holen um weiter Rekursion auszuführen
Ca a ... je nach Ergebnis von (p%i==0) wird der linke oder rechte Teil ausgeführt - das zweite a ist notwendig, da in [3c] dann [B] stehen wird und B wieder eckig geklammert ist


Vorteile:
+) Stack wird nicht unnötig groß aufgebaut, sondern i gleich in-place dekrementiert.
+) Sobald ein Zeuge gefunden ist für das gilt p%i==0 (keine Primzahl), bricht der Algorithmus ab.

Nachteile:
-) Es werden alle Zahlen von p-1 bis 2 durchiteriert und nicht nur die "relevanten" Primzahlen.
-) Für Zahlen p<2 liefert der Algorithmus auch True.
